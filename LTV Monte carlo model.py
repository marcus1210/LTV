import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import PercentFormatter

# This function simulates the revenue generated by n customers
def LTV(ARPU,GM,churn,n):
    month_churned = [] # A vector representing the months in which the customers churned
    for customer in range(n):
        customer_churned = False # A flag which tells us if this customer already churned or not
        month = 1
        while customer_churned == False:
            if np.random.binomial(1,churn) == 1: # Here is the randomness - we generate a Bernoulli random variable that is 0 with 1-churn prob and is 1 with churn probability
                customer_churned = True
                month_churned.append(month)
            else: # If he does not churn, we add another month and then generate another random variable to see if he churned the next month
                month += 1 
    # Now we have information about when each customer churned in the variable "month_churned"   
    # But we need to transform this information to revenue each month          
    revenues_per_month = [ARPU * GM * n] # A vector showing the revenue in each month of projection - in the first month all n customers pay the revenue
    customers_per_month = [n] # A vector showing number of customers in each month of projection
    month_churned = np.array(month_churned)
    for month in range(1,max(month_churned) + 1): # For each month we check how many customers are still active so we can generate revenue for that month
        customers_per_month.append(n - len(month_churned[month_churned <= month])) # From n customers at the beginning we subtract the ones who churned before month x
        revenues_per_month.append( (n - len(month_churned[month_churned <= month])) * ARPU * GM)
    average_LTV = sum(revenues_per_month)/n    
    return(average_LTV)    
    
    
    
def LTV_short_code(ARPU,GM,churn,n): # Shorter and also much faster code if n is big
    month_churned = np.random.geometric(churn,n)
    customers_per_month = np.array([n-len(month_churned[month_churned <= month]) for month in range(0,max(month_churned) + 1)])
    revenues_per_month = ARPU * GM  * customers_per_month
    average_LTV = sum(revenues_per_month)/n
    return(average_LTV)  
    
    
    
###  how different GM and churns rates affect the LTV. -


GMs = np.arange(0.45,0.65,0.05)
churns = np.arange(0.01,0.11,0.01)
LTVs_small_business = np.array([[0.0 for i in range(len(GMs))] for k in range(len(churns))])
LTVs_medium_business = np.array([[0.0 for i in range(len(GMs))] for k in range(len(churns))])

for k in range(len(churns)):
    for i in range(len(GMs)):
        GM = GMs[i]
        churn = churns[k]
        LTVs_small_business[k][i] = LTV_short_code(300,GM,churn,10000)
        LTVs_medium_business[k][i] = LTV_short_code(700,GM,churn,10000)
        
        

LTVs_medium_business = pd.DataFrame(LTVs_medium_business,columns=["45%","50%","55%","60%"],index=[str(round(churns[i]*100))+"%" for i in range(len(churns))])
LTVs_small_business = pd.DataFrame(LTVs_small_business,columns=["45%","50%","55%","60%"],index=[str(round(churns[i]*100))+"%" for i in range(len(churns))])


plt.plot(LTVs_medium_business.iloc[1,:])
plt.title("Impact of GM is linearly increasing with churn rate 2% and ARPU 700 $ fixed")
plt.show()
plt.plot(LTVs_medium_business.iloc[:,1])
plt.title("Impact of churn rate is exponentially decreasing with GM 50% and ARPU 700 $ fixed")
plt.show()

LTVs_medium_business.to_excel("LTVs medium size business.xlsx")
LTVs_small_business.to_excel("LTVs small size business.xlsx")
    
    
### The function above will be used on 1 customer only but we will generate it a 1000 times to get a distribution for two
### groups of customers - a small-sized business and a medium-sized business
    
small_business = [LTV(300,0.5,0.02,1) for customer in range(1000)] # This is a vector of 1000 LTVs for the small business
average_LTV_small_business = np.mean(small_business)
medium_business = [LTV(700,0.5,0.01,1) for customer in range(1000)] # This is a vector of 1000 LTVs for the small business
average_LTV_medium_business = np.mean(medium_business)
    


def VaR(vector,percentile):
    vector.sort()
    return(vector[round(len(vector)*percentile)])

def plot_LTV_dist(LTVs,size): # A function that takes as input a vector f customer values and plots the distribution+
    if size == "small":
        col = "lightblue"
    else:
        col = "blue"
    plt.hist(LTVs, 20, weights = np.ones(len(LTVs))/len(LTVs), facecolor=col, alpha=0.7,ec="black")
    #plt.xlabel("$")
    plt.ylabel('Probability')
    plt.title("Distribution of LTVs for a "+size+"-sized business")
    plt.grid(False)
    plt.gca().yaxis.set_major_formatter(PercentFormatter(1))
    mean = np.mean(LTVs)
    std = np.std(LTVs)
    VaR5 = VaR(LTVs,0.05)
    plt.gcf().text(0.5, 0.74, r"Mean = "+str(round(mean,2))+"\nStd. Deviation = "+str(round(std,2))+"\nVaR at 5% = "+str(round(VaR5,2)))
    plt.show()
    
    
    
    
plot_LTV_dist(small_business,"small")
plot_LTV_dist(medium_business,"medium")





